\section{Implèmentassions}
 
%il faut ajouter references
Les ACLs sont fréquemment implèmentèes comme extensions du noyau, c'est à dire des modules un systéme LINUX. L'objectif de cette section est d'expliquer de maniére globale l'implèmentions des ACL. 

%@@
------------------Le discussion doit lancer la base pour les èvaluations de performance et les problémes dans les sessions prochaines.----------
 
"Les ACLs sont des informations de taille variable qui sont associèes avec les objets du systéme de fichier"\cite{aclsuse}. Plusieurs implèmentations des ACLs sont possibles. Par exemple, avec Solaris, dans le systéme de fichier UFS\cite{acl_permission} chaque \emph{inode} peut avoir une ACL. S'l en a une, il doit avoir l'information \emph{i\_shadow}, un pointeur pour un \emph{shadow inode}. Les \emph{shadow inode} sont comment fichiers règuliérs d'utilisateurs. Différent fichiers avec les mÍmes ACL peut avoir pointeurs pour le mÍme \emph{shadow inodes}. Les information des ACL sont garde dans les bloc de donnèes de chaque \emph{shadow inodes}.
 
La capacitè d'associer des informations avec des fichiers est utilisè dans plusieurs fonctions du systéme de exploitation. De ce fait, la plupart des systémes \emph{UNIX-like} (de type Linux) on trouve les Attributs …tendus (\emph{Extended Attributes (EAs)}). Les ACL sont implèmentèes avec ce mècanisme.

%@@ 
La manpage \cite{aclsuse} \emph{attr(5)} contient des explications prècises sur les EAs dans Linux, ------------au notre but, suffit dire que comme les variables des processus, les EAs sont des paires (nom, valeur) associèes de maniére persistantes avec les objets du systéme de fichiers et que les appels Linux, dans le espace de utilisateur, sont employè pour opèrer sur les information de ces paires dans le espace de adresse du noyaux. Aussi pour l'implèmentation de cette infrastructure dans les systéme FreeBSD il faut voir le article de Robert Watson\cite{trust}. -------------------------------Cette article content aussi une comparaison de plusieurs implèmentation de ces systéme.
 
%@@
Dans le monde linux, ajouter le support aux ACL avec une version limitèe des EA offre plusieurs avantages: un grande facilitè d'implèmentation, ----------------opèration atomique et interface \emph{stateless} que laisse aucun surcharge à cause de les \emph{file handlers}. On verra aprés dans la section de performance, que l'efficience est assez importante pour Ítre oublier quand on parle de les donnès frèquentent accés comme les ACL.-----------------
 
\subsection{Les EAs et les systémes de fichiers}
 
Dans le monde UNIX, chaque systéme de fichier a une différent implèmentation pour les EAs. On peut penser qu'une solution partagèe pour l'ensemble des systémes pourait Ítre plus efficace. Par exemple, si on prend une solution simple où chaque objet du systéme de fichiers a les EAs, un rèpertoire avec un fichier qui a le clès EA comment le nom et le contenu comment le valeur. Cette implèmentation consommerait beaucoup de espace, ètant donnè que les blocks du systéme de fichier seront gaspillès pour conserver petit morceaux de donnè, aussi ce solution perdrait les temps pour chercher ces information a chaque accés de fichier. Aux frais de ces problémes chaque systéme tire profit de ces qualitès pour ajouter le supporte aux EAs.
 
\subsubsection*{Ext (2,3 et 4)}
 
Les ACL dans Ext suivent le principe linux: "La solution la plus simple qui marche" et pour cette raison subviennent quelques limitations. D'autres solutions existent, par contre, elle sont difficiles à ajouter au noyau de maniére satisfaisante\cite{ext_acl}.
 
La solution actuelle ajoute aux \emph{i\_node} une entrèe qui s'appelle \emph{i\_file\_acl}. Cette entrèe, si différent de 0, est une ponteur sur un bloc d'EAs. Ce bloc d'EAs a les informations de nom et valeur de tous les ACL du fichier indiquè pour cet \emph{i\_node}.
 
Le mècanisme a aussi une optimisation. Deux fichiers avec le mÍme ensemble de ACL point vers le mÍme bloc d'EAs. Le systéme garde une \emph{hash map} avec les \emph{checksum} des blocs d'EAs et leurs adresse. Chaque block a aussi un compteur de rèfèrence, comme les liens \emph{hard}. Ce mècanisme dètermine aussi que ce compteur là ne peut pas avoir plus que 1024 rèfèrences. Il s'agit d'une mesure de sècuritè en cas de perte des donnèes.
 
Aussi une limitation est imposèe: toutes les donnèes des EAs d'un fichier doivent occuper un bloc d'EAs ayant une taille de 1, 2 ou 4 KBs.
 
 
\subsubsection*{JFS}
 
Dans JFS, les EAs sont ajoutèes dans une liste consècutive de blocs contigus (un extent).  Cela veut dire que chaque paire (nom,valeur) est gardèe en sèquence et que chaque valeur de la paire ne peut pas Ítre plus grande que 64kb. Si les EAs sont assez petites, elles pourrons Ítre gardèes dans le mÍme lieu que les informations du fichier. De ce faÁon, il n'y a pas les limitations d'ext3.
 
\subsubsection*{XFS}
XFS est sans aucun dout le systéme de fichiers le plus simple pour implèmenter les EA. Les paires d'EA de petite tailles sont stockèes directement dans l'inode, celles de taille moyenne sont stockèes dans les blocs feuilles de l'arbre binaire et pour celle de grande taille, dans un arbre binaire complet.------------manque--------
XFS peut configurer la taille de sa table d'inodes. La taille minimale est de 256 octet et la taille maximale peut aller jusqu'à la moitiè des blocs du systéme de fichier. Dans le cas où on a une table de taille minimale, celle-ci n'est pas assez grande pour accueillir les ACLs. On doit alors les stocker de maniére externe ----au systéme de fichier----. Si on augmente la taille de la table les ACL pourront y Ítre stockèes. Les ACL ètant trés souvent interrogèes par le systéme, cela augmente les performances en terme de temps d'accés au dètriment de l'espace disque qu'elles consomment.
XFS n'a pas de mècanisme de partage des attributs. La taille individuelle des attributs est limitèe à 64Kb.
 
\subsubsection*{ReiserFS}

%@@

ReiserFS support le \emph{tail merging} qui permet à plusieurs fichiers de partager le mÍme bloc pour stocker leurs donnèes. Cela rend le systéme trés efficace pour s'il on posséde de nombreux fichiers de petite taille. De l'autre cÙtè cette technique consomme beaucoup de ressources CPU. 

Comme le ReiserFs peut facilement manipuler des petits fichiers, les EA peuvent Ítre implèmentèes sous forme de petits fichiers. Pour chaque fichiers qui a un EA, un dossier spècial (qui est souvent cachè) est crèè avec un nom dèrivè de son inode. Dans ce dossier chaque EA est stockèe dans un fichier sèparè qui a pour nom le nom de l'attribut. Le contenu de chaque fichier est la valeur de l'attribut.

Le systéme ReiserFS n'implèmente pas le partage d'attributs mais la crèation d'une extension pour le gèrer est possible. La taille individuelle des attributs est limitèe à 64Kb.

%@@
----------------------Sharing could even be implemented
on a per-attribute bases, so the result would be
a highly efficient and flexible solution. --------------The size of individual
attributes is limited to 64 KiB.

\subsubsection*{HGFS+}

%@@
\section*{Système de Fichier Remote}
%@@
\subsubsection*{Samba}
%@@

\subsubsection*{NFS}
%@@
